package retriever

import (
	"bufio"
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"time"

	"github.com/CESSProject/cess-crypto/gosdk"
	"github.com/CESSProject/go-sdk/chain"
	"github.com/ChainSafe/go-schnorrkel"
	"github.com/pkg/errors"
	"github.com/vedhavyas/go-subkey/sr25519"
)

const (
	GATEWAY_GENTOKEN_URL      = "/gateway/gentoken"
	GATEWAY_UPLOADFILE_URL    = "/gateway/upload/file"
	GATEWAY_PARTUPLOAD_URL    = "/gateway/part-upload"
	GATEWAY_UPLOADPART_URL    = "/gateway/upload/part"
	GATEWAY_GETFILE_URL       = "/gateway/download"
	RETRIEVER_QUERYDATA_URL   = "/querydata"
	RETRIEVER_FETCHDATA_URL   = "/cache-fetch"
	RETRIEVER_NODESTATUS_URL  = "/status"
	RETRIEVER_GETCAPACITY_URL = "/capacity"

	DEFAULT_PART_SIZE = 32 * 1024 * 1024
)

type Response struct {
	Code int    `json:"code"`
	Msg  string `json:"msg"`
	Data any    `json:"data"`
}

type FileInfo struct {
	Fid       string     `json:"fid"`
	FileName  string     `json:"file_name"`
	BaseDir   string     `json:"base_dir"`
	FileSize  int64      `json:"file_size"`
	Owner     []byte     `json:"owner"`
	Territory string     `json:"territory"`
	Segments  []string   `json:"segments"`
	Fragments [][]string `json:"fragments"`
}

type PartsInfo struct {
	ShadowHash string    `json:"shadow_hash,omitempty"`
	FileName   string    `json:"file_name,omitempty"`
	DirName    string    `json:"dir_name,omitempty"`
	Archive    string    `json:"archive,omitempty"`
	Territory  string    `json:"territory,omitempty"`
	Parts      []string  `json:"parts,omitempty"`
	PartsCount int       `json:"parts_count,omitempty"`
	TotalParts int       `json:"total_parts,omitempty"`
	PartSize   int64     `json:"-"`
	TotalSize  int64     `json:"total_size,omitempty"`
	UpdateDate time.Time `json:"update_date,omitempty"`
}

// GenReEncryptionKey generates a re-encryption key and corresponding public key using Schnorrkel scheme.
// This implements proxy re-encryption mechanism for decentralized storage systems.
//
// Parameters:
//
//	mnemonic - User's mnemonic phrase for key derivation
//	pkB      - Recipient's public key bytes (32-byte expected)
//
// Returns:
//
//	[]byte - Marshaled re-encryption key (rk)
//	[]byte - Encoded public key bytes for encryption (pkX)
//	error  - Possible errors include:
//	           - Invalid mnemonic phrase
//	           - Public key deserialization failure
//	           - Re-encryption key generation failure
//	           - Key serialization failure
func GenReEncryptionKey(mnemonic string, pkB []byte) ([]byte, []byte, error) {
	if len(pkB) != 32 {
		return nil, nil, errors.Wrap(errors.New("public key length error"), "generate re-encryption key error")
	}
	ms, err := schnorrkel.MiniSecretKeyFromMnemonic(mnemonic, "")
	if err != nil {
		return nil, nil, errors.Wrap(err, "generate re-encryption key error")
	}
	secret := ms.ExpandEd25519()
	var pkbArray [32]byte
	copy(pkbArray[:], pkB[:32])
	pubkeyB, err := schnorrkel.NewPublicKey(pkbArray)
	if err != nil {
		return nil, nil, errors.Wrap(err, "generate re-encryption key error")
	}
	rk, pkX, err := gosdk.GenReKey(secret, pubkeyB)
	if err != nil {
		return nil, nil, errors.Wrap(err, "generate re-encryption key error")
	}
	txtRk, err := rk.MarshalText()
	if err != nil {
		return nil, nil, errors.Wrap(err, "generate re-encryption key error")
	}
	pkxArray := pkX.Encode()
	return txtRk, pkxArray[:], nil
}

// DownloadData retrieves data from the gateway and writes it to local file system.
// Handles HTTP headers for decryption when re-encryption key (rk) and public key (pkX) are provided.
//
// Parameters:
//
//	baseUrl  - Base URL of the gateway service
//	fid      - File id
//	segment  - Segment id
//	fpath    - Local path to save downloaded file
//	capsule  - Proxy re-encryption capsule
//	rk       - Re-encryption key bytes, generated by the re-encrypt method
//	pkX      - Public key bytes for encryption, generated by the re-encrypt method
//
// Returns:
//
//	error - Possible errors include:
//	          - URL construction failure
//	          - HTTP request failure
//	          - File creation/write failure
func DownloadData(baseUrl, fid, segment, fpath string, capsule, rk, pkX []byte) error {
	u, err := url.JoinPath(baseUrl, "/gateway/download", fid, segment)
	if err != nil {
		return errors.Wrap(err, "download data from gateway error")
	}
	headers := map[string]string{}
	if len(rk) > 0 && len(pkX) > 0 {
		headers["Capsule"] = string(capsule)
		headers["Rkb"] = string(rk)
		headers["Pkx"] = chain.EncodePubkey(pkX, 11330)
	}
	body, err := SendHttpRequest(http.MethodGet, u, headers, bytes.NewBuffer(nil))
	if err != nil {
		return errors.Wrap(err, "download data from gateway error")
	}
	f, err := os.Create(fpath)
	if err != nil {
		return errors.Wrap(err, "download data from gateway error")
	}
	defer f.Close()
	if _, err = f.Write(body); err != nil {
		return errors.Wrap(err, "download data from gateway error")
	}
	return nil
}

// GetPreCapsuleAndGatewayPubkey retrieves pre-encapsulation capsule data and gateway public key for a given file
// by sending HTTP GET request to the gateway service. This is essential for subsequent encryption operations.
//
// Parameters:
//
//	baseUrl - Base URL of the gateway service
//	fid     - Unique file identifier
//
// Returns:
//
//	[]byte - Proxy re-encryption capsule
//	[]byte - Gateway's public key
//	error  - Possible errors include:
//	           - URL construction failure
//	           - HTTP request failure
//	           - JSON unmarshalling failure
func GetPreCapsuleAndGatewayPubkey(baseUrl, fid string) ([]byte, []byte, error) {

	u, err := url.JoinPath(baseUrl, "/gateway/capsule", fid)
	if err != nil {
		return nil, nil, errors.Wrap(err, "get pre capsule and gateway pubkey error")
	}
	body, err := SendHttpRequest(http.MethodGet, u, nil, bytes.NewBuffer(nil))
	if err != nil {
		return nil, nil, errors.Wrap(err, "get pre capsule and gateway pubkey error")
	}
	data := map[string][]byte{}
	resp := Response{
		Data: &data,
	}
	if err = json.Unmarshal(body, &resp); err != nil {
		return nil, nil, errors.Wrap(err, "get pre capsule and gateway pubkey error")
	}
	return data["capsule"], data["pubkey"], nil
}

// SignedSR25519WithMnemonic signs a message using the SR25519 scheme with a given mnemonic.
// It appends "<Bytes>" and "</Bytes>" to the message before signing.
// Parameters:
//
//	mnemonic - The mnemonic phrase used for signing.
//	msg - The message to be signed.
//
// Returns:
//
//	[]byte - The signed message.
//	error - An error if the mnemonic is invalid or signing fails.
func SignedSR25519WithMnemonic(mnemonic string, msg []byte) ([]byte, error) {

	pri, err := sr25519.Scheme{}.FromPhrase(mnemonic, "")
	if err != nil {
		return nil, errors.New("invalid mnemonic")
	}
	hd := sha256.Sum256(msg)
	msg = append([]byte("<Bytes>"), append(hd[:], []byte("</Bytes>")...)...)
	return pri.Sign(msg)
}

// GenGatewayAccessToken generates an access token for the gateway using the provided base URL, message, account, and signature.
// It sends a POST request to the "/gateway/gentoken" endpoint with the necessary parameters.
// Message must be the current Unix timestamp (seconds) and expire after one minute to prevent the signature from being reused maliciously.
// Parameters:
//
//	baseUrl - The base URL of the gateway.
//	message - The message to be signed.
//	account - The account associated with the token.
//	sign - The signature of the message.
//
// Returns:
//
//	string - The generated access token.
//	error - An error if the request fails or the response is invalid.
func GenGatewayAccessToken(baseUrl, message, account string, sign []byte) (string, error) {
	var (
		token  string
		err    error
		buffer *bytes.Buffer
	)
	data := url.Values{
		"account": {account},
		"message": {message},
		"sign":    {hex.EncodeToString(sign)},
	}
	dataString := data.Encode()
	buffer = bytes.NewBufferString(dataString)
	u, err := url.JoinPath(baseUrl, GATEWAY_GENTOKEN_URL)
	if err != nil {
		return token, errors.Wrap(err, "gen gateway access token error")
	}
	headers := map[string]string{
		"Content-Type": "application/x-www-form-urlencoded",
	}
	body, err := SendHttpRequest(http.MethodPost, u, headers, buffer)
	if err != nil {
		return token, errors.Wrap(err, "gen gateway access token error")
	}
	resp := Response{
		Data: &token,
	}
	err = json.Unmarshal(body, &resp)
	if err != nil {
		return token, errors.Wrap(err, "gen gateway access token error")
	}
	return token, nil
}

func uploadFile(baseUrl, token, territory, filename string, file io.Reader, async, noProxy, encrypt bool) ([]byte, error) {
	var (
		err    error
		buffer bytes.Buffer
	)
	writer := multipart.NewWriter(&buffer)
	writer.WriteField("territory", territory)
	if async {
		writer.WriteField("async", "true")
	}
	if noProxy {
		writer.WriteField("noProxy", "true")
	}
	if encrypt {
		writer.WriteField("encrypt", "true")
	}

	part, err := writer.CreateFormFile("file", filename)
	if err != nil {
		return nil, errors.Wrap(err, "upload user file error")
	}
	if _, err = io.Copy(part, file); err != nil {
		return nil, errors.Wrap(err, "upload user file error")
	}

	if err = writer.Close(); err != nil {
		return nil, errors.Wrap(err, "upload user file error")
	}
	headers := map[string]string{
		"Content-Type": writer.FormDataContentType(),
		"token":        fmt.Sprintf("Bearer %s", token),
	}
	u, err := url.JoinPath(baseUrl, GATEWAY_UPLOADFILE_URL)
	if err != nil {
		return nil, errors.Wrap(err, "upload user file error")
	}
	body, err := SendHttpRequest(http.MethodPost, u, headers, &buffer)
	if err != nil {
		return nil, errors.Wrap(err, "upload user file error")
	}
	return body, nil
}

// UploadFile uploads a file to the specified territory.
// It sends a POST request to the "/gateway/upload/file" endpoint with the necessary parameters.
// Parameters:
//
//		baseUrl - The base URL of the gateway.
//		token - The access token for authentication.
//		territory - The territory to which the file will be uploaded.
//		filename - The name of the file to be uploaded.
//		file - The file content to be uploaded.
//	    encrypt - Whether the data needs to be encrypted (using proxy re-encryption technology)
//
// Returns:
//
//	string - The file identifier (FID) if the upload is successful.
//	error - An error if the upload fails.
func UploadFile(baseUrl, token, territory, filename string, file io.Reader, encrypt bool) (string, error) {
	var (
		fid string
	)
	body, err := uploadFile(baseUrl, token, territory, filename, file, false, false, encrypt)
	if err != nil {
		return "", errors.Wrap(err, "synchronous upload failed")
	}
	resp := Response{
		Data: &fid,
	}
	if err = json.Unmarshal(body, &resp); err != nil {
		return fid, errors.Wrap(err, "synchronous upload failed")
	}
	return fid, nil
}

// AsyncUploadFile uploads a file asynchronously to the specified territory.
// It sends a POST request to the "/gateway/upload/file" endpoint with the necessary parameters.
// Parameters:
//
//		baseUrl - The base URL of the gateway.
//		token - The access token for authentication.
//		territory - The territory to which the file will be uploaded.
//		filename - The name of the file to be uploaded.
//		file - The file content to be uploaded.
//		noProxy - Whether to not create file orders through OSS proxy.
//	    encrypt - Whether the data needs to be encrypted (using proxy re-encryption technology)
//
// Returns:
//
//	FileInfo - Information about the uploaded file.
//	error - An error if the upload fails.
func AsyncUploadFile(baseUrl, token, territory, filename string, file io.Reader, noProxy, encrypt bool) (FileInfo, error) {
	var (
		info FileInfo
		fid  string
	)
	body, err := uploadFile(baseUrl, token, territory, filename, file, true, noProxy, encrypt)
	if err != nil {
		return info, errors.Wrap(err, "asynchronous upload failed")
	}
	resp := Response{
		Data: &fid,
	}
	if noProxy {
		resp.Data = &info
	}
	if err = json.Unmarshal(body, &resp); err != nil {
		return info, errors.Wrap(err, "asynchronous upload failed")
	}
	if fid != "" && info.Fid == "" {
		info.Fid = fid
	}
	return info, nil
}

func uploadFileParts(baseUrl, token, fpath string, info *PartsInfo, async, noProxy, encrypt bool) ([]byte, error) {
	var (
		err    error
		buffer bytes.Buffer
	)
	writer := multipart.NewWriter(&buffer)
	writer.WriteField("shadowhash", info.ShadowHash)
	writer.WriteField("partid", fmt.Sprint(info.PartsCount))
	if async {
		writer.WriteField("async", "true")
	}
	if noProxy {
		writer.WriteField("noProxy", "true")
	}
	if encrypt {
		writer.WriteField("encrypt", "true")
	}
	part, err := writer.CreateFormFile("file", info.Parts[info.PartsCount])
	if err != nil {
		return nil, errors.Wrap(err, "upload file part error")
	}

	if info.DirName != "" {
		file, err := os.Open(filepath.Join(fpath, info.Parts[info.PartsCount]))
		if err != nil {
			return nil, errors.Wrap(err, "upload file part error")
		}
		defer file.Close()
		_, err = io.Copy(part, file)
		if err != nil {
			return nil, errors.Wrap(err, "upload file part error")
		}

	} else {
		file, err := os.Open(fpath)
		if err != nil {
			return nil, errors.Wrap(err, "upload file part error")
		}
		defer file.Close()
		size := info.PartSize
		_, err = file.Seek(int64(info.PartsCount)*size, io.SeekStart)
		if err != nil {
			return nil, errors.Wrap(err, "upload file part error")
		}
		if int64(info.PartsCount+1)*size > info.TotalSize {
			size = info.TotalSize % size
		}
		_, err = io.CopyN(part, file, size)
		if err != nil {
			return nil, errors.Wrap(err, "upload file part error")
		}
		if err := writer.Close(); err != nil {
			return nil, errors.Wrap(err, "upload file part error")
		}
	}

	headers := map[string]string{
		"Content-Type": writer.FormDataContentType(),
		"token":        fmt.Sprintf("Bearer %s", token),
	}
	u, err := url.JoinPath(baseUrl, GATEWAY_UPLOADPART_URL)
	if err != nil {
		return nil, errors.Wrap(err, "upload file part error")
	}
	body, err := SendHttpRequest(http.MethodPost, u, headers, &buffer)
	if err != nil {
		return nil, errors.Wrap(err, "upload file part error")
	}
	info.PartsCount++
	return body, nil
}

// UploadFileParts uploads file parts to the specified territory.
// It sends a POST request to the "/gateway/upload/part" endpoint with the necessary parameters.
// Parameters:
//
//	baseUrl - The base URL of the gateway.
//	token - The access token for authentication.
//	fpath - The path of the file to be uploaded.
//	info - Information about the file parts to be uploaded.
//	encrypt - Whether the data needs to be encrypted (using proxy re-encryption technology)
//
// Returns:
//
//	string - The file identifier (FID) if the upload is successful.
//	error - An error if the upload fails.
func UploadFileParts(baseUrl, token, fpath string, info *PartsInfo, encrypt bool) (string, error) {
	var (
		fid string
	)
	body, err := uploadFileParts(baseUrl, token, fpath, info, false, false, encrypt)
	if err != nil {
		return fid, errors.Wrap(err, "synchronous upload failed")
	}
	resp := Response{}
	if err = json.Unmarshal(body, &resp); err != nil {
		return fid, errors.Wrap(err, "synchronous upload failed")
	}
	fid = fmt.Sprint(resp.Data)
	return fid, nil
}

// AsyncUploadFileParts uploads file parts asynchronously to the specified territory.
// It sends a POST request to the "/gateway/upload/part" endpoint with the necessary parameters.
// Parameters:
//
//	baseUrl - The base URL of the gateway.
//	token - The access token for authentication.
//	fpath - The path of the file to be uploaded.
//	info - Information about the file parts to be uploaded.
//	noProxy - Whether to not create file orders through OSS proxy.
//	encrypt - Whether the data needs to be encrypted (using proxy re-encryption technology)
//
// Returns:
//
//	FileInfo - Information about the uploaded file.
//	error - An error if the upload fails.
func AsyncUploadFileParts(baseUrl, token, fpath string, info *PartsInfo, noProxy, encrypt bool) (FileInfo, error) {
	var (
		finfo FileInfo
		resp  Response
		pid   string
	)
	body, err := uploadFileParts(baseUrl, token, fpath, info, true, false, encrypt)
	if err != nil {
		return finfo, errors.Wrap(err, "asynchronous upload failed")
	}
	if info.PartsCount == info.TotalParts && noProxy {
		resp.Data = &finfo
	} else {
		resp.Data = &pid
	}
	if err = json.Unmarshal(body, &resp); err != nil {
		return finfo, errors.Wrap(err, "asynchronous upload failed")
	}
	if pid != "" && finfo.Fid == "" {
		finfo.Fid = pid
	}
	return finfo, nil
}

// RequestToUploadParts requests to upload file parts to the specified territory.
// It sends a POST request to the "/gateway/part-upload" endpoint with the necessary parameters.
// Parameters:
//
//	baseUrl - The base URL of the gateway.
//	token - The access token for authentication.
//	fpath - The path of the file to be uploaded.
//	territory - The territory to which the file will be uploaded.
//	filename - The name of the file to be uploaded.
//	achive - The archive name of the file to be uploaded.
//	partSize - The size of each part to be uploaded.
//
// Returns:
//
//	PartsInfo - Information about the file parts to be uploaded.
//	error - An error if the request fails.
func RequestToUploadParts(baseUrl, fpath, token, territory, filename, achive string, partSize int64) (PartsInfo, error) {
	var info PartsInfo
	fs, err := os.Stat(fpath)
	if err != nil {
		return info, errors.Wrap(err, "request to upload file parts error")
	}
	if fs.IsDir() {
		info, err = CreatePartsInfoForDir(fpath, filename, achive)
		if err != nil {
			return info, errors.Wrap(err, "request to upload file parts error")
		}
	} else {
		info, err = CreatePartsInfoForFile(fpath, filename, fs.Size(), partSize)
		if err != nil {
			return info, errors.Wrap(err, "request to upload file parts error")
		}
	}
	info.Territory = territory
	info.UpdateDate = time.Now()
	headers := map[string]string{
		"Content-Type": "application/json",
		"token":        fmt.Sprintf("Bearer %s", token),
	}
	u, err := url.JoinPath(baseUrl, GATEWAY_PARTUPLOAD_URL)
	if err != nil {
		return info, errors.Wrap(err, "request to upload file parts error")
	}
	jbytes, err := json.Marshal(info)
	if err != nil {
		return info, errors.Wrap(err, "request to upload file parts error")
	}
	_, err = SendHttpRequest(http.MethodPost, u, headers, bytes.NewBuffer(jbytes))
	return info, errors.Wrap(err, "request to upload file parts error")
}

// CreatePartsInfoForFile creates parts information for a file.
// It calculates the hash of each part and the shadow hash of the file.
// Parameters:
//
//	fpath - The path of the file.
//	filename - The name of the file.
//	fileSize - The size of the file.
//	partSize - The size of each part.
//
// Returns:
//
//	PartsInfo - Information about the file parts.
//	error - An error if the file cannot be opened or read.
func CreatePartsInfoForFile(fpath, filename string, fileSize, partSize int64) (PartsInfo, error) {

	if partSize <= DEFAULT_PART_SIZE {
		partSize = DEFAULT_PART_SIZE
	}
	if partSize > fileSize {
		partSize = fileSize
	}
	if filename == "" {
		filename = filepath.Base(fpath)
	}
	info := PartsInfo{
		FileName:   filename,
		TotalSize:  fileSize,
		PartSize:   partSize,
		TotalParts: int((fileSize + (partSize - fileSize%partSize)) / partSize),
	}

	f, err := os.Open(fpath)
	if err != nil {
		return info, errors.Wrap(err, "create parts info for file error")
	}
	defer f.Close()
	reader := bufio.NewReader(f)
	info.Parts = make([]string, 0, info.TotalParts)
	hash := sha256.New()
	buf := make([]byte, partSize)
	for i := 0; i < info.TotalParts; i++ {
		n, err := reader.Read(buf)
		if err != nil {
			return info, errors.Wrap(err, "create parts info for file error")
		}
		partHash := sha256.Sum256(buf[:n])
		info.Parts = append(info.Parts, hex.EncodeToString(partHash[:]))
		if n >= 32 {
			hash.Write(buf[:32])
		} else {
			hash.Write(buf[:n])
			hash.Write(make([]byte, 32-n))
		}
	}
	info.ShadowHash = hex.EncodeToString(hash.Sum(nil))
	return info, nil
}

// CreatePartsInfoForDir creates parts information for a directory.
// It calculates the hash of each file in the directory and the shadow hash of the directory.
// Parameters:
//
//	fpath - The path of the directory.
//	dirname - The name of the directory.
//	archive - The name of the archive.
//
// Returns:
//
//	PartsInfo - Information about the directory parts.
//	error - An error if the directory cannot be opened or read.
func CreatePartsInfoForDir(fpath, dirname, archive string) (PartsInfo, error) {
	info := PartsInfo{
		DirName: dirname,
		Archive: archive,
	}
	entries, err := os.ReadDir(fpath)
	if err != nil {
		return info, errors.Wrap(err, "create parts info for dir error")
	}
	info.Parts = make([]string, 0, len(entries))
	hash := sha256.New()
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		f, err := os.Open(filepath.Join(fpath, entry.Name()))
		if err != nil {
			return info, errors.Wrap(err, "create parts info for dir error")
		}
		buf := make([]byte, 32)
		if _, err = f.Read(buf); err != nil {
			f.Close()
			return info, errors.Wrap(err, "create parts info for dir error")
		}
		stat, err := f.Stat()
		if err != nil {
			f.Close()
			return info, errors.Wrap(err, "create parts info for dir error")
		}
		hash.Write(buf)
		info.Parts = append(info.Parts, f.Name())
		info.TotalParts++
		info.TotalSize += stat.Size()
		f.Close()
	}
	info.ShadowHash = hex.EncodeToString(hash.Sum(nil))
	return info, nil
}

func SendHttpRequest(method, url string, headers map[string]string, dataReader *bytes.Buffer) ([]byte, error) {
	req, err := http.NewRequest(method, url, dataReader)
	if err != nil {
		return nil, errors.Wrap(err, "send http request error")
	}
	for k, v := range headers {
		req.Header.Add(k, v)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "send http request error")
	}
	defer resp.Body.Close()

	bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "send http request error")
	}

	if resp.StatusCode >= 400 {
		err = fmt.Errorf("bad request, status code %d, error %v", resp.StatusCode, string(bytes))
		return nil, errors.Wrap(err, "send http request error")
	}

	return bytes, nil
}
