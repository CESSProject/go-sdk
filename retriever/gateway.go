package retriever

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/url"
	"os"
	"time"

	"github.com/CESSProject/go-sdk/chain"
	"github.com/pkg/errors"
	"github.com/vedhavyas/go-subkey/sr25519"
)

const (
	GATEWAY_GENTOKEN_URL      = "/gateway/gentoken"
	GATEWAY_UPLOADFILE_URL    = "/gateway/upload/file"
	GATEWAY_BATCHUPLOAD_URL   = "/gateway/upload/batch/file"
	GATEWAY_BATCHREQUEST_URL  = "/gateway/upload/batch/request"
	GATEWAY_GETFILE_URL       = "/gateway/download"
	RETRIEVER_QUERYDATA_URL   = "/querydata"
	RETRIEVER_FETCHDATA_URL   = "/cache-fetch"
	RETRIEVER_NODESTATUS_URL  = "/status"
	RETRIEVER_GETCAPACITY_URL = "/capacity"

	DEFAULT_PART_SIZE = 32 * 1024 * 1024
)

type Response struct {
	Code int    `json:"code"`
	Msg  string `json:"msg"`
	Data any    `json:"data"`
}

type ReencryptReq struct {
	Did     string `json:"did"`
	Capsule []byte `json:"capsule"`
	Rk      []byte `json:"rk"`
}

type FileInfo struct {
	Fid       string     `json:"fid"`
	FileName  string     `json:"file_name"`
	BaseDir   string     `json:"base_dir"`
	FileSize  int64      `json:"file_size"`
	Owner     []byte     `json:"owner"`
	Territory string     `json:"territory"`
	Segments  []string   `json:"segments"`
	Fragments [][]string `json:"fragments"`
}

type BatchFilesInfo struct {
	Hash         string    `json:"hash,omitempty"`
	FileName     string    `json:"file_name,omitempty"`
	Owner        []byte    `json:"owner,omitempty"`
	Territory    string    `json:"territory,omitempty"`
	FilePath     string    `json:"-"`
	UploadedSize int64     `json:"uploaded_size,omitempty"`
	TotalSize    int64     `json:"total_size,omitempty"`
	AsyncUpload  bool      `json:"async_upload,omitempty"`
	NoTxProxy    bool      `json:"no_tx_proxy,omitempty"`
	Encrypt      bool      `json:"encrypt,omitempty"`
	UpdateDate   time.Time `json:"update_date,omitempty"`
}

type BatchUploadResp struct {
	Fid      string   `json:"fid"`
	ChunkEnd int64    `json:"chunk_end"`
	FileInfo FileInfo `json:"file_info"`
}

// ProxyReEncrypt performs proxy re-encryption by sending a request to the gateway server.
// This handles remote cryptographic transformation of capsules for decentralized storage access.
//
// Parameters:
//
//	baseUrl - Gateway server base URL (e.g., "https://api.example.com")
//	token   - Authentication token for gateway API access
//	did     - Decentralized identifier for target data
//	capsule - Original encrypted capsule bytes (JSON marshaled)
//	rk      - Re-encryption key bytes (ristretto255 scalar serialization)
//
// Returns:
//
//	[]byte - Re-encrypted capsule bytes (JSON marshaled)
//	error  - Possible errors include:
//	           - Invalid URL path construction
//	           - Request payload serialization failure
//	           - Gateway communication failure
//	           - Response payload deserialization failure
func ProxyReEncrypt(baseUrl, token, did string, capsule, rk []byte) ([]byte, error) {
	u, err := url.JoinPath(baseUrl, "/gateway/reencrypt")
	if err != nil {
		return nil, errors.Wrap(err, "proxy re-encrypt key error")
	}
	jbytes, err := json.Marshal(ReencryptReq{
		Did:     did,
		Capsule: capsule,
		Rk:      rk,
	})
	if err != nil {
		return nil, errors.Wrap(err, "proxy re-encrypt key error")
	}
	body, err := SendHttpRequest(http.MethodPost, u, nil, bytes.NewBuffer(jbytes))
	if err != nil {
		return nil, errors.Wrap(err, "proxy re-encrypt key error")
	}
	newCapsule := []byte{}
	resp := Response{
		Data: &newCapsule,
	}
	if err = json.Unmarshal(body, &resp); err != nil {
		return nil, errors.Wrap(err, "proxy re-encrypt key error")
	}
	return newCapsule, nil
}

// DownloadData retrieves data from the gateway and writes it to local file system.
// Handles HTTP headers for decryption when re-encryption key (rk) and public key (pkX) are provided.
//
// Parameters:
//
//	baseUrl  - Base URL of the gateway service
//	fid      - File id
//	segment  - Segment id
//	fpath    - Local path to save downloaded file
//	capsule  - Proxy re-encryption capsule
//	rk       - Re-encryption key bytes, generated by the re-encrypt method
//	pkX      - Public key bytes for encryption, generated by the re-encrypt method
//
// Returns:
//
//	error - Possible errors include:
//	          - URL construction failure
//	          - HTTP request failure
//	          - File creation/write failure
func DownloadData(baseUrl, fid, segment, fpath string, capsule, rk, pkX []byte) error {
	u, err := url.JoinPath(baseUrl, "/gateway/download", fid, segment)
	if err != nil {
		return errors.Wrap(err, "download data from gateway error")
	}
	headers := map[string]string{}
	if len(rk) > 0 && len(pkX) > 0 {
		headers["Capsule"] = string(capsule)
		headers["Rkb"] = string(rk)
		headers["Pkx"] = chain.EncodePubkey(pkX, 11330)
	}
	body, err := SendHttpRequest(http.MethodGet, u, headers, bytes.NewBuffer(nil))
	if err != nil {
		return errors.Wrap(err, "download data from gateway error")
	}
	f, err := os.Create(fpath)
	if err != nil {
		return errors.Wrap(err, "download data from gateway error")
	}
	defer f.Close()
	if _, err = f.Write(body); err != nil {
		return errors.Wrap(err, "download data from gateway error")
	}
	return nil
}

// GetPreCapsuleAndGatewayPubkey retrieves pre-encapsulation capsule data and gateway public key for a given file
// by sending HTTP GET request to the gateway service. This is essential for subsequent encryption operations.
//
// Parameters:
//
//	baseUrl - Base URL of the gateway service
//	fid     - Unique file identifier
//
// Returns:
//
//	[]byte - Proxy re-encryption capsule
//	[]byte - Gateway's public key
//	error  - Possible errors include:
//	           - URL construction failure
//	           - HTTP request failure
//	           - JSON unmarshalling failure
func GetPreCapsuleAndGatewayPubkey(baseUrl, fid string) ([]byte, []byte, error) {

	u, err := url.JoinPath(baseUrl, "/gateway/capsule", fid)
	if err != nil {
		return nil, nil, errors.Wrap(err, "get pre capsule and gateway pubkey error")
	}
	body, err := SendHttpRequest(http.MethodGet, u, nil, bytes.NewBuffer(nil))
	if err != nil {
		return nil, nil, errors.Wrap(err, "get pre capsule and gateway pubkey error")
	}
	data := map[string][]byte{}
	resp := Response{
		Data: &data,
	}
	if err = json.Unmarshal(body, &resp); err != nil {
		return nil, nil, errors.Wrap(err, "get pre capsule and gateway pubkey error")
	}
	return data["capsule"], data["pubkey"], nil
}

// SignedSR25519WithMnemonic signs a message using the SR25519 scheme with a given mnemonic.
// It appends "<Bytes>" and "</Bytes>" to the message before signing.
// Parameters:
//
//	mnemonic - The mnemonic phrase used for signing.
//	msg - The message to be signed.
//
// Returns:
//
//	[]byte - The signed message.
//	error - An error if the mnemonic is invalid or signing fails.
func SignedSR25519WithMnemonic(mnemonic string, msg []byte) ([]byte, error) {

	pri, err := sr25519.Scheme{}.FromPhrase(mnemonic, "")
	if err != nil {
		return nil, errors.New("invalid mnemonic")
	}
	hd := sha256.Sum256(msg)
	msg = append([]byte("<Bytes>"), append(hd[:], []byte("</Bytes>")...)...)
	return pri.Sign(msg)
}

// GenGatewayAccessToken generates an access token for the gateway using the provided base URL, message, account, and signature.
// It sends a POST request to the "/gateway/gentoken" endpoint with the necessary parameters.
// Message must be the current Unix timestamp (seconds) and expire after one minute to prevent the signature from being reused maliciously.
// Parameters:
//
//	baseUrl - The base URL of the gateway.
//	message - The message to be signed.
//	account - The account associated with the token.
//	sign - The signature of the message.
//
// Returns:
//
//	string - The generated access token.
//	error - An error if the request fails or the response is invalid.
func GenGatewayAccessToken(baseUrl, message, account string, sign []byte) (string, error) {
	var (
		token  string
		err    error
		buffer *bytes.Buffer
	)
	data := url.Values{
		"account": {account},
		"message": {message},
		"sign":    {hex.EncodeToString(sign)},
	}
	dataString := data.Encode()
	buffer = bytes.NewBufferString(dataString)
	u, err := url.JoinPath(baseUrl, GATEWAY_GENTOKEN_URL)
	if err != nil {
		return token, errors.Wrap(err, "gen gateway access token error")
	}
	headers := map[string]string{
		"Content-Type": "application/x-www-form-urlencoded",
	}
	body, err := SendHttpRequest(http.MethodPost, u, headers, buffer)
	if err != nil {
		return token, errors.Wrap(err, "gen gateway access token error")
	}
	resp := Response{
		Data: &token,
	}
	err = json.Unmarshal(body, &resp)
	if err != nil {
		return token, errors.Wrap(err, "gen gateway access token error")
	}
	return token, nil
}

func uploadFile(baseUrl, token, territory, filename string, file io.Reader, async, noProxy, encrypt bool) ([]byte, error) {
	var (
		err    error
		buffer bytes.Buffer
	)
	writer := multipart.NewWriter(&buffer)
	writer.WriteField("territory", territory)
	if async {
		writer.WriteField("async", "true")
	}
	if noProxy {
		writer.WriteField("noProxy", "true")
	}
	if encrypt {
		writer.WriteField("encrypt", "true")
	}

	part, err := writer.CreateFormFile("file", filename)
	if err != nil {
		return nil, errors.Wrap(err, "upload user file error")
	}
	if _, err = io.Copy(part, file); err != nil {
		return nil, errors.Wrap(err, "upload user file error")
	}

	if err = writer.Close(); err != nil {
		return nil, errors.Wrap(err, "upload user file error")
	}
	headers := map[string]string{
		"Content-Type": writer.FormDataContentType(),
		"token":        fmt.Sprintf("Bearer %s", token),
	}
	u, err := url.JoinPath(baseUrl, GATEWAY_UPLOADFILE_URL)
	if err != nil {
		return nil, errors.Wrap(err, "upload user file error")
	}
	body, err := SendHttpRequest(http.MethodPost, u, headers, &buffer)
	if err != nil {
		return nil, errors.Wrap(err, "upload user file error")
	}
	return body, nil
}

// UploadFile uploads a file to the specified territory.
// It sends a POST request to the "/gateway/upload/file" endpoint with the necessary parameters.
// Parameters:
//
//		baseUrl - The base URL of the gateway.
//		token - The access token for authentication.
//		territory - The territory to which the file will be uploaded.
//		filename - The name of the file to be uploaded.
//		file - The file content to be uploaded.
//	    encrypt - Whether the data needs to be encrypted (using proxy re-encryption technology)
//
// Returns:
//
//	string - The file identifier (FID) if the upload is successful.
//	error - An error if the upload fails.
func UploadFile(baseUrl, token, territory, filename string, file io.Reader, encrypt bool) (string, error) {
	var (
		fid string
	)
	body, err := uploadFile(baseUrl, token, territory, filename, file, false, false, encrypt)
	if err != nil {
		return "", errors.Wrap(err, "synchronous upload failed")
	}
	resp := Response{
		Data: &fid,
	}
	if err = json.Unmarshal(body, &resp); err != nil {
		return fid, errors.Wrap(err, "synchronous upload failed")
	}
	return fid, nil
}

// AsyncUploadFile uploads a file asynchronously to the specified territory.
// It sends a POST request to the "/gateway/upload/file" endpoint with the necessary parameters.
// Parameters:
//
//		baseUrl - The base URL of the gateway.
//		token - The access token for authentication.
//		territory - The territory to which the file will be uploaded.
//		filename - The name of the file to be uploaded.
//		file - The file content to be uploaded.
//		noProxy - Whether to not create file orders through OSS proxy.
//	    encrypt - Whether the data needs to be encrypted (using proxy re-encryption technology)
//
// Returns:
//
//	FileInfo - Information about the uploaded file.
//	error - An error if the upload fails.
func AsyncUploadFile(baseUrl, token, territory, filename string, file io.Reader, noProxy, encrypt bool) (FileInfo, error) {
	var (
		info FileInfo
		fid  string
	)
	body, err := uploadFile(baseUrl, token, territory, filename, file, true, noProxy, encrypt)
	if err != nil {
		return info, errors.Wrap(err, "asynchronous upload failed")
	}
	resp := Response{
		Data: &fid,
	}
	if noProxy {
		resp.Data = &info
	}
	if err = json.Unmarshal(body, &resp); err != nil {
		return info, errors.Wrap(err, "asynchronous upload failed")
	}
	if fid != "" && info.Fid == "" {
		info.Fid = fid
	}
	return info, nil
}

// RequestBatchUpload initiates a batch file upload session.
// It sends a POST request to the batch upload endpoint with file metadata.
// Parameters:
//
//	baseUrl - The base URL of the gateway.
//	token - The access token for authentication.
//	territory - The territory where the file will be uploaded.
//	filename - The name of the file to be uploaded.
//	fileSize - The total size of the file in bytes.
//	encrypt - Whether the data needs to be encrypted.
//	asyncUpload - Whether to upload asynchronously.
//	noTxProxy - Whether to bypass transaction proxy.
//
// Returns:
//
//	string - A unique hash identifier for the upload session.
//	error - An error if the session initialization fails.
func RequestBatchUpload(baseUrl, token, territory, filename string, fileSize int64, encrypt, asyncUpload, noTxProxy bool) (string, error) {
	jbytes, err := json.Marshal(BatchFilesInfo{
		FileName:    filename,
		Territory:   territory,
		TotalSize:   fileSize,
		Encrypt:     encrypt,
		AsyncUpload: asyncUpload,
		NoTxProxy:   noTxProxy,
	})
	if err != nil {
		return "", errors.Wrap(err, "request batch upload file error")
	}
	headers := map[string]string{
		"Content-Type": "application/json",
		"token":        fmt.Sprintf("Bearer %s", token),
	}
	u, err := url.JoinPath(baseUrl, GATEWAY_BATCHREQUEST_URL)
	if err != nil {
		return "", errors.Wrap(err, "upload user file error")
	}
	body, err := SendHttpRequest(http.MethodPost, u, headers, bytes.NewBuffer(jbytes))
	if err != nil {
		return "", errors.Wrap(err, "upload user file error")
	}
	var (
		hash string
		resp = Response{Data: &hash}
	)
	if err = json.Unmarshal(body, &resp); err != nil {
		return "", errors.Wrap(err, "upload user file error")
	}
	return hash, nil
}

// BatchUploadFile uploads a specific byte range of a file as part of a batch upload session.
// It sends a multipart POST request with the specified byte range to the batch upload endpoint.
// Parameters:
//
//	baseUrl - The base URL of the gateway.
//	token - The access token for authentication.
//	hash - The unique hash identifier obtained from RequestBatchUpload.
//	reader - The io.ReaderAt to read the file content from.
//	start - The starting byte position of the range (inclusive).
//	end - The ending byte position of the range (exclusive).
//
// Returns:
//
//	BatchUploadResp - The upload result or confirmation.
//	error - An error if the chunk upload fails.
func BatchUploadFile(baseUrl, token, hash string, reader io.ReaderAt, start, end int64) (BatchUploadResp, error) {
	var (
		err    error
		buffer bytes.Buffer
		res    BatchUploadResp
	)
	writer := multipart.NewWriter(&buffer)
	part, err := writer.CreateFormFile("file", "part")
	if err != nil {
		return res, errors.Wrap(err, "batch upload file error")
	}
	if start >= end || end <= 0 || start < 0 {
		return res, errors.Wrap(errors.New("bad content bytes range"), "batch upload file error")
	}
	buf := make([]byte, end-start)
	n, err := reader.ReadAt(buf, start)
	if err != nil {
		return res, errors.Wrap(err, "batch upload file error")
	}
	if int64(n) != end-start {
		return res, errors.Wrap(errors.New("invalid data length"), "batch upload file error")
	}
	if _, err = part.Write(buf); err != nil {
		return res, errors.Wrap(err, "batch upload file error")
	}
	if err = writer.Close(); err != nil {
		return res, errors.Wrap(err, "batch upload file error")
	}
	headers := map[string]string{
		"Content-Type": writer.FormDataContentType(),
		"token":        fmt.Sprintf("Bearer %s", token),
		"Range":        fmt.Sprintf("bytes=%d-%d", start, end),
		"hash":         hash,
	}
	u, err := url.JoinPath(baseUrl, GATEWAY_BATCHUPLOAD_URL)
	if err != nil {
		return res, errors.Wrap(err, "batch upload file error")
	}
	body, err := SendHttpRequest(http.MethodPost, u, headers, &buffer)
	if err != nil {
		return res, errors.Wrap(err, "batch upload file error")
	}
	resp := Response{
		Data: &res,
	}
	if err = json.Unmarshal(body, &resp); err != nil {
		return res, errors.Wrap(err, "batch upload file error")
	}
	return res, nil
}

func SendHttpRequest(method, url string, headers map[string]string, dataReader *bytes.Buffer) ([]byte, error) {
	req, err := http.NewRequest(method, url, dataReader)
	if err != nil {
		return nil, errors.Wrap(err, "send http request error")
	}
	for k, v := range headers {
		req.Header.Add(k, v)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "send http request error")
	}
	defer resp.Body.Close()

	bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "send http request error")
	}

	if resp.StatusCode >= 400 {
		err = fmt.Errorf("bad request, status code %d, error %v", resp.StatusCode, string(bytes))
		return nil, errors.Wrap(err, "send http request error")
	}

	return bytes, nil
}
